# Self hosted cloud setup with reverse proxy to a local virtual host backend

This project sets up an NGINX web server using Docker Compose to serve static files with HTTPS enabled, leveraging Let’s Encrypt certificates generated by Certbot.

## Features

* Lightweight NGINX container based on the nginx:alpine image.

* Automatic HTTPS certificate generation using Certbot.

* Support for serving custom static files from the html directory.

* Automatic redirection from HTTP to HTTPS.

* Docker Compose for easy deployment and management.
 

## Requirements

* Docker and Docker Compose installed on your server.
* A domain name (domain.com) pointing to your server’s IP address.
* Certbot installed on your server for certificate generation.


## Project Structure

```
├── docker-compose.yml         # Docker Compose configuration file
├── html/                      # Directory for your static website files
│   └── index.html             # Example HTML file
├── nginx.conf                 # Custom NGINX configuration file
├── certs/                     # Directory for SSL certificates (auto-generated)
└── README.md                  # Documentation for the setup
```

## Setup Instructions
For these instructions, we will be setting up a local virtualhost backend, and a remote cloud-based front end proxy/reverse proxy server.

You will need a DNS domain, the ability to configure sub-domains of this (eg. mail.domain.com, wazuh.domain.com), a cheap cloud instance with a public IP address, and the appropriate A, AAAA, CNAME and TXT and MX records pointing your domain and subdomains to your public IP address/your cheap cloud instance.

You will also need a VPN connecting your remote cloud instance to the computer you want running your virtualhost backend. You can set this up faily painlessly using something like wireguard (https://www.wireguard.com/) or tailscale (https://tailscale.com/).

These two computers need to both be set up. Instructions relating to the reverse proxy server will be under the subheading:

**On your remote server (reverse proxy/proxy/cloud instance)**

Instructions relating to the local backend server will have the subheading:

**On your local server (backend/virtual host)**

There are several reasons why we have split the two roles here:
* to keep cloud costs to a minimum by running all the heavy workloads on your own computers/servers
* to not connect your home network to the internet by making sure all traffic designed for your website/web app is proxied through your cloud instance reverse proxy. If this is done correctly, this will mean that the only part of your setup directly exposed to the internet is the part controlled by the cloud provider.
* if you end up having to scale your infrastructure, having a reverse proxy already set up means transitioning it to being a load balancer etc. will be much easier.

See the diagram below for clarification on how this separation of infrastructure works 

```
                         ┌───────────────────────────┐
                         │         Clients           │
                         │ (User Browsers, Apps, etc)│
                         └────────────┬──────────────┘
                                      │
                                      ▼
                         ┌───────────────────────────┐
                         │       DNS Resolution      │
                         │ (domain.com,           |
                         | cybermonkey.net.au, etc.) │
                         └────────────┬──────────────┘
                                      │
                                      ▼
            **This your remote server (reverse proxy/proxy/cloud instance)**
                           ┌─────────────────┐
                           │   Reverse Proxy │
                           │ (NGINX, Caddy,  │
                           │   Ingress, etc) │
                           └───┬─────────────┘
                               │
      ┌────────────────────────┼─────────────────────────┐
      │                        │                         │
      ▼                        ▼                         ▼
      **These are your local servers (backend/virtual hosts)**
┌──────────────┐       ┌──────────────┐          ┌──────────────┐
│  Backend 1   │       │  Backend 2   │          │  Backend 3   │
│   (vhost5)   │       │   (vhost7)   │          │   (vhost11)  │
│  ┌────────┐  │       │  ┌────────┐  │          │  ┌────────┐  │
│  │ Service│  │       │  │ Service│  │          │  │ Service│  │
│  │ Pod/   │  │       │  │ Pod/   │  │          │  │ Pod/   │  │
│  │ Docker │  │       │  │ Docker │  │          │  │ Docker │  │
│  └────────┘  │       │  └────────┘  │          │  └────────┘  │
└──────────────┘       └──────────────┘          └──────────────┘
```

### 1. Clone the Repository

Clone this repository to your server:
```
su
umask
# 0022 <- Verify it is 0022
cd /opt
git clone codeMonkeyCybersecurity/helen
cd helen
```

Below is a simple, reliable approach to obtain SSL certificates with Certbot and use them in an NGINX Docker container—without battling volume-mount issues for Let’s Encrypt directories. This method involves two separate steps:
1.	Use Certbot on the host (outside of Docker) to obtain certificates.

2.	Mount the certificates into your Dockerized NGINX.

By doing it this way, you avoid dealing with /var/lib/letsencrypt or /etc/letsencrypt inside Docker. Once you have your certificates on the host, you simply share them with the NGINX container.

## 1.	Stop Any Services on Port 80
**On your remote server (reverse proxy/proxy/cloud instance)**
Stop or remove any containers or services (like NGINX) that are currently listening on port 80:
```
docker-compose down
sudo systemctl stop nginx
```
This is necessary because Certbot’s standalone mode needs to bind port 80.

## 2.	Install Certbot on the Remote Host
**On your remote server (reverse proxy/proxy/cloud instance)**
On Ubuntu/Debian:
```
sudo apt update
sudo apt install certbot
```

## 3.	Obtain the Certificates (Standalone Mode)
**On your remote server (reverse proxy/proxy/cloud instance)**
Run Certbot to generate certificates using its built-in standalone server:
```
sudo certbot certonly --standalone \
    -d domain.com \
    --email <you>@<your.email> \
    --agree-tos
```
This will spin up a temporary web server on port 80. Certbot will place certificates in /etc/letsencrypt/live/domain.com/.

### If you're adding Wazuh 
Run Certbot to generate certificates using its built-in standalone server:
```
sudo certbot certonly --standalone \
    -d wazuh.domain.com \
    --email <you>@<your.email> \
    --agree-tos
```

### If you're adding Mailcow 
Run Certbot to generate certificates using its built-in standalone server:
```
sudo certbot certonly --standalone \
    -d mail.domain.com \
    --email <you>@<your.email> \
    --agree-tos
```

## 4.	Verify Certificate Files
After a successful run, check:
```
sudo ls -l /etc/letsencrypt/live/domain.com/
```

You should see:
* cert.pem
* chain.pem
* fullchain.pem
* privkey.pem

## 5.	Create a Local Directory for Docker
Make a local directory in your project for the certs:
```
mkdir -p certs
```
Copy your certificates into it:
```
sudo cp /etc/letsencrypt/live/domain.com/fullchain.pem certs/
sudo cp /etc/letsencrypt/live/domain.com/privkey.pem certs/
```

Adjust permissions to be readable:
```
sudo chmod 644 certs/fullchain.pem
sudo chmod 600 certs/privkey.pem
```

### If you're adding Wazuh 
Copy your certificates into it:
```
sudo cp /etc/letsencrypt/live/wazuh.domain.com/fullchain.pem certs/wazuh.fullchain.pem
sudo cp /etc/letsencrypt/live/wazuh.domain.com/privkey.pem certs/wazuh.privkey.pem
```

Adjust permissions to be readable:
```
sudo chmod 644 certs/wazuh.fullchain.pem
sudo chmod 600 certs/wazuh.privkey.pem
```

### If you're adding Mailcow 
**On your remote server (reverse proxy/proxy/cloud instance)**
Copy your certificates into it:
```
sudo cp /etc/letsencrypt/live/mail.domain.com/fullchain.pem certs/mail.fullchain.pem
sudo cp /etc/letsencrypt/live/mail.domain.com/privkey.pem certs/mail.privkey.pem
```

Adjust permissions to be readable:
```
sudo chmod 644 certs/mail.fullchain.pem
sudo chmod 600 certs/mail.privkey.pem
```

**On your local server (backend/virtual host)**
Install mailcow with:
```
su
umask
# 0022 # <- Verify it is 0022
netstat -tulpn | grep -E -w '25|80|110|143|443|465|587|993|995|4190' # check you can receive traffic on the necessary ports
cd /opt
git clone https://github.com/mailcow/mailcow-dockerized
cd mailcow-dockerized
./generate_config.sh # put in appropriate info
docker compose up -d
```


Full and up to date instructions on https://docs.mailcow.email/getstarted/install/#install-mailcow 


## 6.	Use the Certificates in Docker
**On your remote server (reverse proxy/proxy/cloud instance)**

In your docker-compose.yml, mount the local certs folder into the container:

```
services:
  nginx:
    image: nginx:alpine
    container_name: helen-dev
    volumes:
      - ./:/usr/share/nginx/html:ro # Shared webroot for validation
      - ./nginx.conf:/etc/nginx/nginx.conf:ro # Custom NGINX configuration
      - ./certs:/etc/nginx/certs:ro  # SSL certificates
    ports:
      - "80:80"
      - "443:443"
      - "1514:1514"
      - "1515:1515"
    restart: always
```



## 7.	Configure nginx.conf
**On your remote server (reverse proxy/proxy/cloud instance)**

Point to the copied certs in /etc/nginx/certs:

### For having the webpage set up only
```
server {
    listen 80;
    server_name domain.com;
    return 301 https://$host$request_uri;
}

server {
    listen 443 ssl;
    server_name domain.com;

    ssl_certificate /etc/nginx/certs/fullchain.pem;
    ssl_certificate_key /etc/nginx/certs/privkey.pem;

    location / {
        root /usr/share/nginx/html;
        index index.html;
    }
}
```

### If you're adding Wazuh 
Your nginx.conf file needs to be:
```
server {
    listen 80;
    server_name domain.com;
    return 301 https://$host$request_uri;
}

server {
    listen 443 ssl;
    server_name domain.com;

    ssl_certificate /etc/nginx/certs/fullchain.pem;
    ssl_certificate_key /etc/nginx/certs/privkey.pem;

    location / {
        root /usr/share/nginx/html;
        index index.html;
    }
}

server {
    listen 80;
    server_name wazuh.domain.com;
    return 301 https://$host$request_uri;  # Redirect HTTP to HTTPS
}

server {
    listen 443 ssl;
    server_name wazuh.domain.com;

    # SSL Certificate settings
    ssl_certificate /etc/nginx/certs/wazuh.fullchain.pem;
    ssl_certificate_key /etc/nginx/certs/wazuh.privkey.pem;

    location / {
        # Forward to your Wazuh Dashboard (on IP ww.xx.yy.zz port 5601)
        # If it's HTTP on the backend:
        proxy_pass https://ww.xx.yy.zz:5601/;

        # If the backend is HTTPS with self-signed cert:
        # proxy_pass https://ww.xx.yy.zz:5601/;
        # proxy_ssl_verify off;

        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
```

I recommend using tailscale as a VPN mesh service, installed on each node. See https://tailscale.com/ for more information.

It's very helpful for configuring several VPNs. 

The `proxy_pass https://ww.xx.yy.zz:5601/;` IP address values given above are the local backend server's tailscale IP address.


### If you're adding mailcow
```
worker_processes  auto;

events {
    worker_connections  1024;
}

###
# STREAM BLOCK for mail protocols
###
stream {
    # Upstream definitions: mail services on the local backend
    upstream mailcow_imap_ssl {
        server ww.xx.yy.zz:993;  # IMAP-SSL on the local mailcow
    }
    upstream mailcow_smtp_tls {
        server ww.xx.yy.zz:587;  # SMTP submission on the local mailcow
    }
    # If you want to handle port 25 or 465, you can define them similarly, e.g.:
    # upstream mailcow_smtp25 {
    #     server ww.xx.yy.zz:25;
    # }

    # Listen IMAP over SSL externally
    server {
        listen 993 ssl;
        proxy_pass mailcow_imap_ssl;

        # SSL cert for mail.domain.com
        ssl_certificate /etc/nginx/certs/mail.domain.com.fullchain.pem;
        ssl_certificate_key /etc/nginx/certs/mail.domain.com.privkey.pem;

        # (Optional) SSL Settings
        ssl_protocols       TLSv1.2 TLSv1.3;
        ssl_ciphers         HIGH:!aNULL:!MD5;
    }

    # Listen SMTP submission with STARTTLS externally
    server {
        listen 587 ssl;  # Or if you prefer to do pure TLS on 465, use 465
        proxy_pass mailcow_smtp_tls;

        ssl_certificate /etc/nginx/certs/mail.domain.com.fullchain.pem;
        ssl_certificate_key /etc/nginx/certs/mail.domain.com.privkey.pem;

        ssl_protocols       TLSv1.2 TLSv1.3;
        ssl_ciphers         HIGH:!aNULL:!MD5;
    }

    # (Optional) If you want to forward plain 25 to Mailcow, or do SSL on 465:
    # server {
    #     listen 25;
    #     proxy_pass mailcow_smtp25;
    # }

    # Wazuh streams
    upstream wazuh_manager_1515 {
        server ww.xx.yy.zz:1515;
    }
    server {
        listen 1515;
        proxy_pass wazuh_manager_1515;
    }

    upstream wazuh_manager_1514 {
        server ww.xx.yy.zz:1514;
    }
    server {
        listen 1514;
        proxy_pass wazuh_manager_1514;
    }
}

###
# HTTP BLOCK for Web UI (Mailcow Admin, Wazuh Kibana, Static Site)
###
http {
    include       mime.types;
    default_type  application/octet-stream;

    #--------------------------------------------------
    # 1) MAIN WEBSITE: domain.com
    #--------------------------------------------------
    # Redirect HTTP → HTTPS
    server {
        listen 80;
        server_name domain.com;
        return 301 https://$host$request_uri;
    }

    # The HTTPS server for domain.com
    server {
        listen 443 ssl;
        server_name domain.com;

        ssl_certificate /etc/nginx/certs/fullchain.pem;
        ssl_certificate_key /etc/nginx/certs/privkey.pem;

        location / {
            root /usr/share/nginx/html;
            index index.html;
        }
    }

    #--------------------------------------------------
    # 2) WAZUH: wazuh.domain.com
    #--------------------------------------------------
    server {
        listen 80;
        server_name wazuh.domain.com;
        return 301 https://$host$request_uri;
    }

    server {
        listen 443 ssl;
        server_name wazuh.domain.com;

        ssl_certificate /etc/nginx/certs/wazuh.fullchain.pem;
        ssl_certificate_key /etc/nginx/certs/wazuh.privkey.pem;

        # Proxy pass to Kibana interface on local Wazuh
        location / {
            proxy_pass https://ww.xx.yy.zz:5601/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
    }

    #--------------------------------------------------
    # 3) MAILCOW WEB UI: mail.domain.com
    #--------------------------------------------------
    # - We do HTTP → HTTPS
    server {
        listen 80;
        server_name mail.domain.com;
        return 301 https://$host$request_uri;
    }

    # - We do HTTPS termination and pass traffic to the Mailcow web container
    server {
        listen 443 ssl;
        server_name mail.domain.com;

        ssl_certificate /etc/nginx/certs/mail.domain.com.fullchain.pem;
        ssl_certificate_key /etc/nginx/certs/mail.domain.com.privkey.pem;

        location / {
            proxy_pass http://ww.xx.yy.zz:8080; 
            # ^ Adjust if your Mailcow web UI is mapped differently,
            #   for example: "http://ww.xx.yy.zz:80" if you published it on 80 inside Docker.

            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-Proto $scheme;
        }
    }
}
```

## 8.	Start NGINX
**On your remote server (reverse proxy/proxy/cloud instance)**
With certificates in place and nginx.conf updated, start your container:
```
docker-compose down
docker-compose up -d
```

You should now test your endpoints. Using a **private browsing window**, navigate to:


### For your website
* http://domain.com/ → should redirect to HTTPS.
* https://domain.com/ → should load your static page.


### If you're adding Wazuh 
* https://wazuh.domain.com/ → should proxy to Wazuh.

### If you're adding mailcow
* https://mail.domain.com/ → should load the Mailcow interface.


## Securing the setup 
Below are a few important security considerations:

### Firewall
**On your remote server (reverse proxy/proxy/cloud instance)**
* On the remote proxy server, allow inbound on 80/443 (for web) + the mail ports (993, 587, 25 if needed), 1514, 1515 for Wazuh.

```
sudo ufw status

# for web server 
sudo ufw allow http 
sudo ufw allow https 

# for wazuh
sudo ufw allow 1514
sudo ufw allow 1515
sudo ufw allow 5601
sudo ufw allow 55000
sudo ufw allow 9200

# for mailcow
sudo ufw allow 25
sudo ufw allow 587
sudo ufw allow 993
```
**On your local server (backend/virtual host)**
* On the Mailcow server, consider restricting inbound connections for mail ports (25, 587, 993, etc.) only from your remote proxy server’s IP if you want to force all mail traffic to go through the proxy.
```
# for mailcow
sudo ufw allow 25
sudo ufw allow 587
sudo ufw allow 993
```

* On the wazuh server; allow these ports 
```
# for wazuh
sudo ufw allow 1514
sudo ufw allow 1515
sudo ufw allow 5601
sudo ufw allow 55000
sudo ufw allow 9200
```

### Fail2Ban
* Set up Fail2Ban on the Mailcow server to monitor Dovecot (IMAP) and Postfix (SMTP) logs. This prevents brute-force login attempts.
* You can also run Fail2Ban on the remote proxy, but typically for mail specifically, Fail2Ban is most effective on the actual mail server that has the logs.

### TLS Ciphers
* In your NGINX config, specify strong ciphers:
```
ssl_protocols       TLSv1.2 TLSv1.3;
ssl_ciphers         EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH;
ssl_prefer_server_ciphers on;
```
* Disable weak protocols, etc.

### DNS & SPF/DKIM/DMARC
* Make sure you publish correct SPF records pointing to your server that will send mail.
* Enable DKIM in Mailcow’s admin interface.
* Publish a DMARC record (optional but recommended).



## .	Automate Certificate Renewal (Optional)
* Since Certbot is on your host, just rely on its standard cron-based renewal:
```
sudo certbot renew
```

* If renewal updates your cert files, copy them again into ./certs/ or symlink them.

* Then restart the container for changes to take effect:
```
docker-compose restart
```

## Recap
* Install Certbot on your host, 
* generate certs in /etc/letsencrypt/, 
* copy them into your project folder, 
* and mount them in Docker.